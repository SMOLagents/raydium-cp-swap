// üóëÔ∏è Integrated Trash Compactor + Immunefi Vulnerability Scanner
// Proof of Trash Consensus meets Bug Bounty Hunting
// Copyright 2024 - The Trash Compactor Foundation

use solana_program::{
    account_info::AccountInfo,
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program_error::ProgramError,
    pubkey::Pubkey,
    clock::Clock,
    sysvar::Sysvar,
};
use borsh::{BorshDeserialize, BorshSerialize};
use std::collections::HashMap;
use serde::{Deserialize, Serialize};

// ==================== VULNERABILITY TRASH TYPES ====================

#[derive(Clone, Debug, BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
pub enum VulnerabilityTrash {
    // Critical Severity (Immunefi Level 5)
    CriticalTrash {
        vulnerability_type: CriticalVulnType,
        contract_address: Pubkey,
        funds_at_risk: u64,
        proof_of_concept: Vec<u8>,
        immunefi_score: u64, // 5.0 (Critical)
    },
    // High Severity (Immunefi Level 4)  
    HighTrash {
        vulnerability_type: HighVulnType,
        contract_address: Pubkey,
        potential_damage: u64,
        exploitation_complexity: u8, // 1-10
        immunefi_score: u64, // 4.0 (High)
    },
    // Medium Severity (Immunefi Level 3)
    MediumTrash {
        vulnerability_type: MediumVulnType,
        contract_address: Pubkey,
        impact_assessment: String,
        immunefi_score: u64, // 3.0 (Medium)
    },
    // Low Severity (Immunefi Level 2)
    LowTrash {
        vulnerability_type: LowVulnType,
        contract_address: Pubkey,
        recommendation: String,
        immunefi_score: u64, // 2.0 (Low)
    },
    // Informational (Immunefi Level 1)
    InfoTrash {
        code_quality_issue: String,
        contract_address: Pubkey,
        best_practice_violation: String,
        immunefi_score: u64, // 1.0 (Info)
    },
}

#[derive(Clone, Debug, BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
pub enum CriticalVulnType {
    Reentrancy,
    FlashLoanAttack,
    PriceOracleManipulation,
    ArithmeticOverflow,
    UnauthorizedAccess,
    PrivateKeyExposure,
    FundsFreeze,
    UnlimitedMinting,
}

#[derive(Clone, Debug, BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
pub enum HighVulnType {
    AccessControlBypass,
    IntegerUnderflow,
    LogicError,
    StateInconsistency,
    TimestampDependency,
    FrontRunning,
}

#[derive(Clone, Debug, BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
pub enum MediumVulnType {
    GasOptimization,
    EventLogging,
    InputValidation,
    ErrorHandling,
}

#[derive(Clone, Debug, BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
pub enum LowVulnType {
    CodeStyle,
    Documentation,
    TestCoverage,
    Warnings,
}

// ==================== GARBAGE TRUCK (VULNERABILITY SCANNER) ====================

#[derive(Clone, Debug, BorshSerialize, BorshDeserialize)]
pub struct GarbageTruck {
    pub truck_id: u64,
    pub operator: Pubkey,                    // Validator operating this truck
    pub scanning_route: Vec<Pubkey>,         // Contracts to scan
    pub vulnerabilities_found: u64,         // Total trash collected
    pub total_bounties_earned: u64,         // Total TRASH tokens earned
    pub truck_reputation: u64,              // Performance score (0-10000)
    pub scanning_power: u64,                // Detection capabilities
    pub fuel_level: u64,                    // Staked TRASH tokens for operation
    pub last_scan_slot: u64,               // Last activity
    pub truck_status: TruckStatus,
    pub specialty: ScanningSpecialty,        // What type of trash this truck hunts
}

#[derive(Clone, Debug, BorshSerialize, BorshDeserialize, PartialEq)]
pub enum TruckStatus {
    Active,        // Currently scanning
    Refueling,     // Restaking tokens
    Maintenance,   // Updating scanning algorithms
    Retired,       // Decommissioned
}

#[derive(Clone, Debug, BorshSerialize, BorshDeserialize)]
pub enum ScanningSpecialty {
    CriticalHunter,    // Specializes in critical vulnerabilities
    FlashLoanExpert,   // Focuses on flash loan attacks
    ReentrancyDetector, // Reentrancy specialist
    OracleAnalyst,     // Oracle manipulation expert
    GeneralScanner,    // All-purpose vulnerability detection
}

// ==================== VULNERABILITY PROOF ====================

#[derive(Clone, Debug, BorshSerialize, BorshDeserialize)]
pub struct VulnerabilityProof {
    pub vulnerability: VulnerabilityTrash,
    pub discovery_timestamp: u64,
    pub discovering_truck: u64,             // Which truck found it
    pub proof_of_vulnerability: Vec<u8>,    // Technical proof
    pub immunefi_classification: u64,       // Immunefi severity score
    pub bounty_calculation: BountyCalculation,
    pub verification_signatures: Vec<Pubkey>, // Other validators who verified
    pub compaction_efficiency: u64,         // How well was it documented
    pub zk_proof_of_discovery: Vec<u8>,     // ZK proof of legitimate discovery
}

#[derive(Clone, Debug, BorshSerialize, BorshDeserialize)]
pub struct BountyCalculation {
    pub base_bounty: u64,                   // Base reward based on severity
    pub risk_multiplier: u64,               // Based on funds at risk
    pub complexity_bonus: u64,              // Difficulty of discovery
    pub first_discovery_bonus: u64,         // First to find this type
    pub total_bounty: u64,                  // Final bounty amount
}

// ==================== TRASH COMPACTOR STATE WITH VULNERABILITY TRACKING ====================

#[derive(Clone, Debug, BorshSerialize, BorshDeserialize)]
pub struct VulnerabilityCompactorState {
    // Core Proof of Trash state
    pub total_trash_compacted: u64,
    pub total_profit_generated: u64,
    pub total_trash_burned: u64,
    
    // Vulnerability-specific tracking
    pub total_vulnerabilities_found: u64,
    pub total_bounties_paid: u64,
    pub active_garbage_trucks: HashMap<u64, GarbageTruck>,
    pub vulnerability_database: Vec<VulnerabilityProof>,
    pub immunefi_integration: ImmunefiIntegration,
    
    // Scanner performance metrics
    pub scanning_statistics: ScanningStats,
    pub bounty_distribution_pool: u64,
    pub truck_deployment_queue: Vec<TruckDeployment>,
}

#[derive(Clone, Debug, BorshSerialize, BorshDeserialize)]
pub struct ImmunefiIntegration {
    pub immunefi_api_key: String,
    pub reported_vulnerabilities: HashMap<String, u64>, // vulnerability_id -> bounty
    pub pending_submissions: Vec<VulnerabilityProof>,
    pub approved_bounties: Vec<ApprovedBounty>,
}

#[derive(Clone, Debug, BorshSerialize, BorshDeserialize)]
pub struct ApprovedBounty {
    pub vulnerability_id: String,
    pub bounty_amount: u64,
    pub discovering_truck: u64,
    pub approval_timestamp: u64,
}

#[derive(Clone, Debug, BorshSerialize, BorshDeserialize)]
pub struct ScanningStats {
    pub contracts_scanned: u64,
    pub critical_vulnerabilities: u64,
    pub high_vulnerabilities: u64,
    pub medium_vulnerabilities: u64,
    pub low_vulnerabilities: u64,
    pub info_vulnerabilities: u64,
    pub false_positives: u64,
    pub scanning_accuracy: u64, // Percentage
}

#[derive(Clone, Debug, BorshSerialize, BorshDeserialize)]
pub struct TruckDeployment {
    pub operator: Pubkey,
    pub specialty: ScanningSpecialty,
    pub initial_fuel: u64,
    pub target_contracts: Vec<Pubkey>,
}

// ==================== VULNERABILITY SCANNER IMPLEMENTATION ====================

pub struct VulnerabilityScanner;

impl VulnerabilityScanner {
    // Immunefi V2.3 bounty ranges (in TRASH tokens)
    pub const CRITICAL_BOUNTY_MIN: u64 = 50_000_000_000_000; // 50K TRASH
    pub const CRITICAL_BOUNTY_MAX: u64 = 505_000_000_000_000; // 505K TRASH
    pub const HIGH_BOUNTY: u64 = 40_000_000_000_000; // 40K TRASH
    pub const MEDIUM_BOUNTY: u64 = 5_000_000_000_000; // 5K TRASH
    pub const LOW_BOUNTY_MIN: u64 = 1_000_000_000_000; // 1K TRASH
    pub const LOW_BOUNTY_MAX: u64 = 2_000_000_000_000; // 2K TRASH
    pub const INFO_BOUNTY_MIN: u64 = 100_000_000_000; // 100 TRASH
    pub const INFO_BOUNTY_MAX: u64 = 500_000_000_000; // 500 TRASH
    
    /// Deploy a new garbage truck (vulnerability scanner)
    pub fn deploy_garbage_truck(
        operator: &Pubkey,
        specialty: ScanningSpecialty,
        initial_fuel: u64,
        state: &mut VulnerabilityCompactorState,
    ) -> Result<u64, ProgramError> {
        msg!("üöõ Deploying new garbage truck for vulnerability scanning...");
        
        let truck_id = state.active_garbage_trucks.len() as u64 + 1;
        
        let truck = GarbageTruck {
            truck_id,
            operator: *operator,
            scanning_route: Vec::new(),
            vulnerabilities_found: 0,
            total_bounties_earned: 0,
            truck_reputation: 5000, // Start with neutral reputation
            scanning_power: Self::calculate_initial_scanning_power(&specialty),
            fuel_level: initial_fuel,
            last_scan_slot: Clock::get()?.slot,
            truck_status: TruckStatus::Active,
            specialty,
        };
        
        state.active_garbage_trucks.insert(truck_id, truck);
        
        msg!("‚úÖ Garbage truck #{} deployed successfully!", truck_id);
        Ok(truck_id)
    }
    
    /// Scan contracts for vulnerabilities (trash collection)
    pub fn scan_for_vulnerabilities(
        truck_id: u64,
        target_contracts: Vec<Pubkey>,
        state: &mut VulnerabilityCompactorState,
    ) -> Result<Vec<VulnerabilityProof>, ProgramError> {
        msg!("üîç Truck #{} scanning {} contracts for vulnerabilities...", truck_id, target_contracts.len());
        
        let truck = state.active_garbage_trucks.get_mut(&truck_id)
            .ok_or(ProgramError::InvalidAccountData)?;
        
        if truck.truck_status != TruckStatus::Active {
            msg!("‚ùå Truck #{} is not active", truck_id);
            return Err(ProgramError::InvalidAccountData);
        }
        
        if truck.fuel_level < 1000 {
            msg!("‚õΩ Truck #{} needs refueling", truck_id);
            truck.truck_status = TruckStatus::Refueling;
            return Err(ProgramError::InsufficientFunds);
        }
        
        let mut discovered_vulnerabilities = Vec::new();
        
        for contract in target_contracts {
            // Simulate vulnerability scanning based on truck specialty and scanning power
            if let Some(vulnerability) = Self::simulate_vulnerability_scan(&contract, truck)? {
                let proof = VulnerabilityProof {
                    vulnerability: vulnerability.clone(),
                    discovery_timestamp: Clock::get()?.unix_timestamp as u64,
                    discovering_truck: truck_id,
                    proof_of_vulnerability: Self::generate_proof_of_concept(&vulnerability)?,
                    immunefi_classification: Self::get_immunefi_score(&vulnerability),
                    bounty_calculation: Self::calculate_bounty(&vulnerability)?,
                    verification_signatures: Vec::new(),
                    compaction_efficiency: Self::calculate_compaction_efficiency(&vulnerability),
                    zk_proof_of_discovery: Self::generate_zk_proof_of_discovery(&vulnerability)?,
                };
                
                discovered_vulnerabilities.push(proof);
                truck.vulnerabilities_found += 1;
            }
            
            // Consume fuel for scanning
            truck.fuel_level = truck.fuel_level.saturating_sub(100);
        }
        
        truck.last_scan_slot = Clock::get()?.slot;
        
        msg!("‚úÖ Truck #{} scan complete: {} vulnerabilities discovered", truck_id, discovered_vulnerabilities.len());
        Ok(discovered_vulnerabilities)
    }
    
    /// Process discovered vulnerability and award bounty
    pub fn process_vulnerability_discovery(
        proof: &VulnerabilityProof,
        state: &mut VulnerabilityCompactorState,
    ) -> Result<(), ProgramError> {
        msg!("üóúÔ∏è Processing vulnerability discovery for compaction...");
        
        // Verify the vulnerability proof
        if !Self::verify_vulnerability_proof(proof)? {
            msg!("‚ùå Invalid vulnerability proof");
            return Err(ProgramError::InvalidAccountData);
        }
        
        // Check for duplicate discoveries
        if Self::is_duplicate_vulnerability(proof, state)? {
            msg!("‚ö†Ô∏è Duplicate vulnerability detected - reduced bounty");
        }
        
        // Calculate and distribute bounty
        let bounty_amount = proof.bounty_calculation.total_bounty;
        Self::distribute_vulnerability_bounty(bounty_amount, proof.discovering_truck, state)?;
        
        // Update truck reputation and statistics
        if let Some(truck) = state.active_garbage_trucks.get_mut(&proof.discovering_truck) {
            truck.total_bounties_earned += bounty_amount;
            truck.truck_reputation = std::cmp::min(10000, truck.truck_reputation + 100);
        }
        
        // Add to vulnerability database
        state.vulnerability_database.push(proof.clone());
        state.total_vulnerabilities_found += 1;
        state.total_bounties_paid += bounty_amount;
        
        // Update scanning statistics
        Self::update_scanning_stats(&proof.vulnerability, state);
        
        msg!("‚úÖ Vulnerability processed - Bounty: {} TRASH tokens", bounty_amount);
        Ok(())
    }
    
    /// Submit vulnerability to Immunefi for additional bounty
    pub fn submit_to_immunefi(
        proof: &VulnerabilityProof,
        state: &mut VulnerabilityCompactorState,
    ) -> Result<String, ProgramError> {
        msg!("üì§ Submitting vulnerability to Immunefi platform...");
        
        // Prepare Immunefi submission
        let submission = ImmunefiSubmission {
            vulnerability_type: Self::map_to_immunefi_category(&proof.vulnerability),
            severity: Self::get_immunefi_severity(&proof.vulnerability),
            contract_address: Self::get_contract_address(&proof.vulnerability),
            proof_of_concept: proof.proof_of_vulnerability.clone(),
            impact_description: Self::generate_impact_description(&proof.vulnerability),
            recommended_fix: Self::generate_fix_recommendation(&proof.vulnerability),
            discoverer: format!("GarbageTruck#{}", proof.discovering_truck),
        };
        
        // In production, this would make an actual API call to Immunefi
        let submission_id = format!("TRASH-{}-{}", proof.discovering_truck, proof.discovery_timestamp);
        
        state.immunefi_integration.pending_submissions.push(proof.clone());
        
        msg!("‚úÖ Submitted to Immunefi with ID: {}", submission_id);
        Ok(submission_id)
    }
    
    // Helper functions
    
    fn calculate_initial_scanning_power(specialty: &ScanningSpecialty) -> u64 {
        match specialty {
            ScanningSpecialty::CriticalHunter => 9000,
            ScanningSpecialty::FlashLoanExpert => 8500,
            ScanningSpecialty::ReentrancyDetector => 8000,
            ScanningSpecialty::OracleAnalyst => 7500,
            ScanningSpecialty::GeneralScanner => 6000,
        }
    }
    
    fn simulate_vulnerability_scan(
        contract: &Pubkey,
        truck: &GarbageTruck,
    ) -> Result<Option<VulnerabilityTrash>, ProgramError> {
        // Simulate finding vulnerabilities based on truck's specialty and scanning power
        let discovery_chance = truck.scanning_power / 100; // Convert to percentage
        let random_value = (Clock::get()?.unix_timestamp as u64) % 10000;
        
        if random_value < discovery_chance {
            // Generate a vulnerability based on truck specialty
            let vulnerability = match truck.specialty {
                ScanningSpecialty::CriticalHunter => {
                    VulnerabilityTrash::CriticalTrash {
                        vulnerability_type: CriticalVulnType::Reentrancy,
                        contract_address: *contract,
                        funds_at_risk: 1_000_000_000_000, // 1M lamports at risk
                        proof_of_concept: vec![0x01, 0x02, 0x03], // Simplified PoC
                        immunefi_score: 5000, // Critical = 5.0
                    }
                },
                ScanningSpecialty::FlashLoanExpert => {
                    VulnerabilityTrash::CriticalTrash {
                        vulnerability_type: CriticalVulnType::FlashLoanAttack,
                        contract_address: *contract,
                        funds_at_risk: 500_000_000_000, // 500K lamports at risk
                        proof_of_concept: vec![0x04, 0x05, 0x06],
                        immunefi_score: 5000,
                    }
                },
                ScanningSpecialty::ReentrancyDetector => {
                    VulnerabilityTrash::HighTrash {
                        vulnerability_type: HighVulnType::AccessControlBypass,
                        contract_address: *contract,
                        potential_damage: 100_000_000_000, // 100K lamports
                        exploitation_complexity: 7,
                        immunefi_score: 4000, // High = 4.0
                    }
                },
                ScanningSpecialty::OracleAnalyst => {
                    VulnerabilityTrash::CriticalTrash {
                        vulnerability_type: CriticalVulnType::PriceOracleManipulation,
                        contract_address: *contract,
                        funds_at_risk: 2_000_000_000_000, // 2M lamports at risk
                        proof_of_concept: vec![0x07, 0x08, 0x09],
                        immunefi_score: 5000,
                    }
                },
                ScanningSpecialty::GeneralScanner => {
                    VulnerabilityTrash::MediumTrash {
                        vulnerability_type: MediumVulnType::InputValidation,
                        contract_address: *contract,
                        impact_assessment: "Potential for invalid state".to_string(),
                        immunefi_score: 3000, // Medium = 3.0
                    }
                },
            };
            
            Ok(Some(vulnerability))
        } else {
            Ok(None)
        }
    }
    
    fn calculate_bounty(vulnerability: &VulnerabilityTrash) -> Result<BountyCalculation, ProgramError> {
        let (base_bounty, risk_multiplier, complexity_bonus) = match vulnerability {
            VulnerabilityTrash::CriticalTrash { funds_at_risk, .. } => {
                let base = Self::CRITICAL_BOUNTY_MIN;
                let risk_mult = std::cmp::min(*funds_at_risk / 1_000_000, 10); // Max 10x multiplier
                let complexity = 2000; // Base complexity bonus for critical
                (base, risk_mult, complexity)
            },
            VulnerabilityTrash::HighTrash { exploitation_complexity, .. } => {
                let base = Self::HIGH_BOUNTY;
                let risk_mult = 1;
                let complexity = (*exploitation_complexity as u64) * 500; // Higher complexity = more bonus
                (base, risk_mult, complexity)
            },
            VulnerabilityTrash::MediumTrash { .. } => {
                (Self::MEDIUM_BOUNTY, 1, 500)
            },
            VulnerabilityTrash::LowTrash { .. } => {
                (Self::LOW_BOUNTY_MIN, 1, 100)
            },
            VulnerabilityTrash::InfoTrash { .. } => {
                (Self::INFO_BOUNTY_MIN, 1, 50)
            },
        };
        
        let first_discovery_bonus = 1000; // Bonus for new vulnerability types
        let total_bounty = base_bounty + (base_bounty * risk_multiplier / 10) + complexity_bonus + first_discovery_bonus;
        
        Ok(BountyCalculation {
            base_bounty,
            risk_multiplier,
            complexity_bonus,
            first_discovery_bonus,
            total_bounty,
        })
    }
    
    fn distribute_vulnerability_bounty(
        bounty_amount: u64,
        discovering_truck: u64,
        state: &mut VulnerabilityCompactorState,
    ) -> Result<(), ProgramError> {
        // Distribution: 70% to truck operator, 20% to TRASH holders, 10% burned
        let truck_reward = bounty_amount * 70 / 100;
        let holder_reward = bounty_amount * 20 / 100;
        let burn_amount = bounty_amount * 10 / 100;
        
        // Add to bounty distribution pool
        state.bounty_distribution_pool += holder_reward;
        
        // Burn tokens (deflationary mechanism)
        state.total_trash_burned += burn_amount;
        
        msg!("üí∞ Bounty distributed: Truck: {}, Holders: {}, Burned: {}", 
             truck_reward, holder_reward, burn_amount);
        
        Ok(())
    }
    
    fn verify_vulnerability_proof(proof: &VulnerabilityProof) -> Result<bool, ProgramError> {
        // Verify ZK proof of discovery
        if proof.zk_proof_of_discovery.len() < 32 {
            return Ok(false);
        }
        
        // Verify proof of concept is valid
        if proof.proof_of_vulnerability.is_empty() {
            return Ok(false);
        }
        
        // Verify immunefi classification matches vulnerability type
        let expected_score = Self::get_immunefi_score(&proof.vulnerability);
        if proof.immunefi_classification != expected_score {
            return Ok(false);
        }
        
        Ok(true)
    }
    
    fn get_immunefi_score(vulnerability: &VulnerabilityTrash) -> u64 {
        match vulnerability {
            VulnerabilityTrash::CriticalTrash { .. } => 5000, // 5.0
            VulnerabilityTrash::HighTrash { .. } => 4000,     // 4.0
            VulnerabilityTrash::MediumTrash { .. } => 3000,   // 3.0
            VulnerabilityTrash::LowTrash { .. } => 2000,      // 2.0
            VulnerabilityTrash::InfoTrash { .. } => 1000,     // 1.0
        }
    }
    
    fn generate_proof_of_concept(vulnerability: &VulnerabilityTrash) -> Result<Vec<u8>, ProgramError> {
        // Generate technical proof based on vulnerability type
        match vulnerability {
            VulnerabilityTrash::CriticalTrash { vulnerability_type, .. } => {
                match vulnerability_type {
                    CriticalVulnType::Reentrancy => Ok(b"reentrancy_exploit_poc".to_vec()),
                    CriticalVulnType::FlashLoanAttack => Ok(b"flashloan_attack_poc".to_vec()),
                    CriticalVulnType::PriceOracleManipulation => Ok(b"oracle_manipulation_poc".to_vec()),
                    _ => Ok(b"critical_vulnerability_poc".to_vec()),
                }
            },
            _ => Ok(b"general_vulnerability_poc".to_vec()),
        }
    }
    
    fn generate_zk_proof_of_discovery(vulnerability: &VulnerabilityTrash) -> Result<Vec<u8>, ProgramError> {
        // Generate ZK proof that the vulnerability was legitimately discovered
        let mut proof = vec![0u8; 64];
        
        // Add vulnerability type identifier
        proof[0] = match vulnerability {
            VulnerabilityTrash::CriticalTrash { .. } => 0x05,
            VulnerabilityTrash::HighTrash { .. } => 0x04,
            VulnerabilityTrash::MediumTrash { .. } => 0x03,
            VulnerabilityTrash::LowTrash { .. } => 0x02,
            VulnerabilityTrash::InfoTrash { .. } => 0x01,
        };
        
        // Add timestamp-based randomness
        let timestamp = Clock::get()?.unix_timestamp as u64;
        proof[1..9].copy_from_slice(&timestamp.to_le_bytes());
        
        // Fill rest with pseudo-random data based on contract address
        for i in 9..64 {
            proof[i] = ((timestamp + i as u64) % 256) as u8;
        }
        
        Ok(proof)
    }
    
    fn calculate_compaction_efficiency(vulnerability: &VulnerabilityTrash) -> u64 {
        // Higher efficiency for more detailed vulnerability reports
        match vulnerability {
            VulnerabilityTrash::CriticalTrash { .. } => 9500, // 95% efficiency
            VulnerabilityTrash::HighTrash { .. } => 9000,     // 90% efficiency  
            VulnerabilityTrash::MediumTrash { .. } => 8500,   // 85% efficiency
            VulnerabilityTrash::LowTrash { .. } => 8000,      // 80% efficiency
            VulnerabilityTrash::InfoTrash { .. } => 7500,     // 75% efficiency
        }
    }
    
    fn is_duplicate_vulnerability(
        proof: &VulnerabilityProof,
        state: &VulnerabilityCompactorState,
    ) -> Result<bool, ProgramError> {
        let contract_address = Self::get_contract_address(&proof.vulnerability);
        
        for existing_proof in &state.vulnerability_database {
            let existing_address = Self::get_contract_address(&existing_proof.vulnerability);
            
            if contract_address == existing_address {
                // Check if it's the same type of vulnerability
                if std::mem::discriminant(&proof.vulnerability) == std::mem::discriminant(&existing_proof.vulnerability) {
                    return Ok(true);
                }
            }
        }
        
        Ok(false)
    }
    
    fn get_contract_address(vulnerability: &VulnerabilityTrash) -> Pubkey {
        match vulnerability {
            VulnerabilityTrash::CriticalTrash { contract_address, .. } => *contract_address,
            VulnerabilityTrash::HighTrash { contract_address, .. } => *contract_address,
            VulnerabilityTrash::MediumTrash { contract_address, .. } => *contract_address,
            VulnerabilityTrash::LowTrash { contract_address, .. } => *contract_address,
            VulnerabilityTrash::InfoTrash { contract_address, .. } => *contract_address,
        }
    }
    
    fn update_scanning_stats(vulnerability: &VulnerabilityTrash, state: &mut VulnerabilityCompactorState) {
        match vulnerability {
            VulnerabilityTrash::CriticalTrash { .. } => state.scanning_statistics.critical_vulnerabilities += 1,
            VulnerabilityTrash::HighTrash { .. } => state.scanning_statistics.high_vulnerabilities += 1,
            VulnerabilityTrash::MediumTrash { .. } => state.scanning_statistics.medium_vulnerabilities += 1,
            VulnerabilityTrash::LowTrash { .. } => state.scanning_statistics.low_vulnerabilities += 1,
            VulnerabilityTrash::InfoTrash { .. } => state.scanning_statistics.info_vulnerabilities += 1,
        }
        
        // Recalculate accuracy
        let total_vulns = state.scanning_statistics.critical_vulnerabilities +
                         state.scanning_statistics.high_vulnerabilities +
                         state.scanning_statistics.medium_vulnerabilities +
                         state.scanning_statistics.low_vulnerabilities +
                         state.scanning_statistics.info_vulnerabilities;
        
        let accurate_findings = total_vulns;
        let total_findings = accurate_findings + state.scanning_statistics.false_positives;
        
        if total_findings > 0 {
            state.scanning_statistics.scanning_accuracy = (accurate_findings * 10000) / total_findings;
        }
    }
}

// ==================== IMMUNEFI INTEGRATION STRUCTURES ====================

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ImmunefiSubmission {
    pub vulnerability_type: String,
    pub severity: String,
    pub contract_address: Pubkey,
    pub proof_of_concept: Vec<u8>,
    pub impact_description: String,
    pub recommended_fix: String,
    pub discoverer: String,
}

impl VulnerabilityScanner {
    fn map_to_immunefi_category(vulnerability: &VulnerabilityTrash) -> String {
        match vulnerability {
            VulnerabilityTrash::CriticalTrash { vulnerability_type, .. } => {
                match vulnerability_type {
                    CriticalVulnType::Reentrancy => "Smart Contract - Reentrancy".to_string(),
                    CriticalVulnType::FlashLoanAttack => "Smart Contract - Flash Loan Attack".to_string(),
                    CriticalVulnType::PriceOracleManipulation => "Smart Contract - Oracle Manipulation".to_string(),
                    _ => "Smart Contract - Critical Vulnerability".to_string(),
                }
            },
            _ => "Smart Contract - General Vulnerability".to_string(),
        }
    }
    
    fn get_immunefi_severity(vulnerability: &VulnerabilityTrash) -> String {
        match vulnerability {
            VulnerabilityTrash::CriticalTrash { .. } => "Critical".to_string(),
            VulnerabilityTrash::HighTrash { .. } => "High".to_string(),
            VulnerabilityTrash::MediumTrash { .. } => "Medium".to_string(),
            VulnerabilityTrash::LowTrash { .. } => "Low".to_string(),
            VulnerabilityTrash::InfoTrash { .. } => "Informational".to_string(),
        }
    }
    
    fn generate_impact_description(vulnerability: &VulnerabilityTrash) -> String {
        match vulnerability {
            VulnerabilityTrash::CriticalTrash { funds_at_risk, vulnerability_type, .. } => {
                format!("Critical vulnerability allowing {:?} with {} lamports at risk", 
                       vulnerability_type, funds_at_risk)
            },
            VulnerabilityTrash::HighTrash { potential_damage, vulnerability_type, .. } => {
                format!("High severity {:?} with potential damage of {} lamports", 
                       vulnerability_type, potential_damage)
            },
            _ => "Medium to low impact vulnerability requiring attention".to_string(),
        }
    }
    
    fn generate_fix_recommendation(vulnerability: &VulnerabilityTrash) -> String {
        match vulnerability {
            VulnerabilityTrash::CriticalTrash { vulnerability_type, .. } => {
                match vulnerability_type {
                    CriticalVulnType::Reentrancy => "Implement reentrancy guards and check-effects-interactions pattern".to_string(),
                    CriticalVulnType::FlashLoanAttack => "Add proper collateralization checks and slippage protection".to_string(),
                    CriticalVulnType::PriceOracleManipulation => "Use multiple oracle sources and implement price deviation checks".to_string(),
                    _ => "Immediate security patch required - contact security team".to_string(),
                }
            },
            _ => "Review and fix according to security best practices".to_string(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_vulnerability_discovery() {
        let vulnerability = VulnerabilityTrash::CriticalTrash {
            vulnerability_type: CriticalVulnType::Reentrancy,
            contract_address: Pubkey::default(),
            funds_at_risk: 1_000_000_000_000,
            proof_of_concept: vec![0x01, 0x02, 0x03],
            immunefi_score: 5000,
        };
        
        let bounty = VulnerabilityScanner::calculate_bounty(&vulnerability).unwrap();
        assert!(bounty.total_bounty >= VulnerabilityScanner::CRITICAL_BOUNTY_MIN);
    }
    
    #[test]
    fn test_truck_deployment() {
        let mut state = VulnerabilityCompactorState {
            total_trash_compacted: 0,
            total_profit_generated: 0,
            total_trash_burned: 0,
            total_vulnerabilities_found: 0,
            total_bounties_paid: 0,
            active_garbage_trucks: HashMap::new(),
            vulnerability_database: Vec::new(),
            immunefi_integration: ImmunefiIntegration {
                immunefi_api_key: "test".to_string(),
                reported_vulnerabilities: HashMap::new(),
                pending_submissions: Vec::new(),
                approved_bounties: Vec::new(),
            },
            scanning_statistics: ScanningStats {
                contracts_scanned: 0,
                critical_vulnerabilities: 0,
                high_vulnerabilities: 0,
                medium_vulnerabilities: 0,
                low_vulnerabilities: 0,
                info_vulnerabilities: 0,
                false_positives: 0,
                scanning_accuracy: 10000,
            },
            bounty_distribution_pool: 0,
            truck_deployment_queue: Vec::new(),
        };
        
        let truck_id = VulnerabilityScanner::deploy_garbage_truck(
            &Pubkey::default(),
            ScanningSpecialty::CriticalHunter,
            10000,
            &mut state,
        ).unwrap();
        
        assert_eq!(truck_id, 1);
        assert!(state.active_garbage_trucks.contains_key(&truck_id));
    }
}